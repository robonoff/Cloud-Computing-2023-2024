1. Abbiamo installato k3s, helmchart, ho pullato l'helmchart di nextcloud modificando poi dei valori scegliendo mariadb e password e admin. 
Abbiamo effettuato il deployment andando a finire su nextcloud, facendo un confronto con il metodo basic in cui abbiamo utilizzato docker-compose per deployare i container. 

2. Abbiamo creato due nodi attraverso boxes, per poi gestirli e settarli tramite virtual machine manager. Abbiamo definito gli indirizzi IP e la rete kubernet attraverso il file kubernet.xml, ed Ã¨ partito tramite il comando virsh (poi trova). In questo modo, abbiamo creato il bridge virbr01, in modo tale da avere un bridge fra i nodi e l'host. 

Dopo averli collegati, abbiamo installato mpi operator sull'intero cluster tramite il master. Abbiamo creato il Dockerfile all'interno del quale abbiamo inserito osu benchmark di mpi operator, per poi costruire l'immagine del container localmente tramite docker, attraverso il comando docker build -f Dockerfile -t osuimage .

In questo modo abbiamo creato l'immagine localmente per poi creare dei file yaml in modo tale che queste immagini siano utilizzate per creare i container all'interno dei pods. Chiaramente, viene costruito su tutti i nodi, non solo sul master. 

I file .yaml sono due, e distribuiscono i pod la prima volta dal master a due nodi, e la seconda volta i pod vengono distribuiti su un solo nodo. 

Due file distinti di benchmarking sono forniti al fine di controllare i tempi di esecuzione. 
